# 2과목 : SQL 기본 및 활용

## 제2장 SQL 활용

1. 순수 관계 연산자와 SQL 문장 비교

   * SELECT 연산은 WHERE 절로 구현 
   * PROJECT 연산은 SELECT 절로 구현 
   * (NATURAL) JOIN 연산은 다양한 JOIN 기능으로 구현 
   * DIVIDE 연산은 현재 사용되지 않음

2. ANSI/ISO SQL에서 표시하는 FROM 절의 JOIN 형태

   * INNER JOIN 
   * NATURAL JOIN 
   * USING 조건절 
   * ON 조건절 
   * CROSS JOIN 
   * OUTER JOIN(LEFT, RIGHT, FULL)

3. INNER JOIN 
   INNER JOIN은 OUTER (외부) JOIN과 대비하여 내부 JOIN이라고 하며 JOIN 조건에서 동일한 값이 있는 행만 반환한다.

4. CROSS JOIN
    테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다. 결과는 양쪽 집합의 M*N 건의 데이터 조합이 발생한다.

5. LEFT OUTER JOIN 
   조인 수행시 먼저 표기된 좌측 테이블에 해당하는 데이터를 먼저 읽은 후, 나중 표기된 우측 테이블에서 JOIN 대상 데이터를 읽어 온다. 즉, Table A와 B가 있을 때 (Table 'A'가 기준이 됨), A와 B를 비교해서 B의 JOIN 칼럼에서 같은 값이 있을 때 그 해당 데이터를 가져오고, B의 JOIN 칼럼에서 같은 값이 없는 경우에는 B 테이블에서 가져오는 칼럼들은 NULL 값으로 채운다.

6. FULL OUTER JOIN
   조인 수행시 좌측, 우측 테이블의 모든 데이터를 읽어 JOIN하여 결과를 생성한다. 즉, TABLE A와 日가 있을 때 (TABLE 'A', 'B' 모두 기준이 됨), RIGHT OUTER JOIN과 LEFT OUTER JOIN의 결과를 합집합으로 처리한 결과와 동일하다.

7. OUTER JOIN 문장 예시

   * LEFT OUTER JOIN

     ```sql
     SELECT X.KEY1,
     Y.KEY2 
     FROM TAB1 X LEFT 
     OUTER JOIN 
     TAB2 Y
     ON (X.KEY1=Y.KEY2)
     ```

   * RIGHT OUTER JOIN

     ```sql
     SELECT X.KEY1, 
     Y.KEY2 
     FROM TAB1 X RIGHT OUTER JOIN 
     TAB2 Y 
     ON (X.KEY1=Y.KEY2)
     ```

   * FULL OUTER JOIN

     ```sql
     SELECT X.KEY1, 
     Y.KEY2 
     FROM TAB1 X FULL 
     OUTER JOIN 
     TAB2 Y 
     ON (X.KEY1=Y.KEY2)
     ```

8. 집합 연산자의 종류

   | 집합 연산자 | 연산자의 의미                                                |
   | ----------- | ------------------------------------------------------------ |
   | UNION       | 여러 개의 SQL문의 결과에 대한 합집합으로 결과에서 모든 중복된 행은 하나의 행으로 만든다. |
   | UNION ALL   | 여러 개의 SQL문의 결과에 대한 합집합으로 중복된 행도 그대로 결과로 표시된다. 즉, 단순히 결과만 합쳐놓은 것이다. 일반적으로 여러 질의 결과가 상호 배타적인(Exclusive)일 때 많이 사용한다. 개별 SQL문의 결과가 서로 중복되지 않는 경우. UNION과 결과가 동일하다. (결과의 정렬 순서에는 차이가 있을 수 있음) |
   | INTERSECT   | 여러 개의 SQL문의 결과에 대한 교집합이다. 중복된 행은 하나의 행으로 만든다. |
   | EXCEPT      | 앞의 SQL문의 결과에서 뒤의 SQL문의 결과에 대한 차집합이다. 중복된 행은 하나의 행으로 만든다. (일부 데이터베이스는 MINUS를 사용함) |

9. SELECT

   ```sql
   SELECT 칼럼명1,
   	칼럼명2, …
   FROM 테이블명1
   [WHERE 조건식 ]
   [[GROUP BY 
   	칼럼(Column)이나 표현식 
   [HAVING 그룹조건식]]
   ```

   * 집합연산자

     ```sql
     SELECT 칼럼명1, 
     	칼럼명2, ... 
     FROM 테이블명2 
     [WHERE 조건식 ] 
     [[GROUP BY 
     	칼럼(Column)이나 표현식 
     [HAVING 그룹조건식 ] ] 
     [ORDER BY 1, 2 
     [ASC또는 DESC];
     ```

   *  ORDER BY는 집합 연산을 적용한 최종 결과에 대한 정렬 처리이므로 가장 마지막 줄에 한번만 기술한다.

10. 일반 집합 연산자를 SQL과 비교

    * UNION 연산은 UNION 기능으로, 
    * INTERSECTION 연산은 INTERSECT 가능으로, 
    * DIFFERENCE 연산은 EXCEPT(Oracle은 MINUS) 가능으로, 
    * PRODUCT 연산은 CROSS JOIN 기능으로 구현되었다.

11. PRIOR 
    : CONNECT BY절에 사용되며, 현재 읽은 칼럼을 지정한다. PRIOR 자식 = 부모 형태를 사용하면 계층구조에서 부모 데이터에서 자식 데이터(부모→자식)방향으로 전개하는 순방향 전개를 한다. 그리고 PRIOR 부모 = 자식 형태를 사용하면 반대로 자식 데이터에서 부모 데이터（자식 → 부모)방향으로 전개하는 역방향 전개를 한다.

12. START WITH와 ORDER SIBLINGS BY

    * START WITH절은 계층 구조 전개의 시작 위치를 지정하는 구문이다. 즉, 루트 데이터를 지정한다.(액세스) 
    * ORDER SIBLINGS BY : 형제 노드(동일 LEVEL) 사이에서 정렬을 수행한다.

13. 계층형 질의

    테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해서 **계층형 질의(Hierarchical Query)**를 사용한다. 계층형 데이터란 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터를 말한다. 애를 들어, 사원 테이블 에서는 사원들 사이에 상위 사원(관리자)과 하위 사원 관계가 존재하고 조직 테이블에서는 조직들 사이에 상위 조직과 하위 조직 관계가 존재한다. 

14. 셀프조인

    **셀프 조인(Self Join)**이란 동일 테이블 사이의 조인을 말한다. 따라서 FROM 절에 동일 테이블이 두 번 이상 나타난다. 동일 테이블 사이의 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 테이블 별칭(Alias)를 사용해야 한다.

    * 셀프 조인(Self Join) 문장

      ```sql
      SELECT ALIAS명1칼럼명,
      	ALIAS명2.칼럼명, ... 
      FROM 
      	테이블 ALIAS명1,
      	테이블 ALIAS명2 
      WHERE 
      	ALIAS명1.칼럼명2 = ALIAS명2.칼럼명1;
      ```

15. 메인쿼리와 서브쿼리

    ![](./images/2_2-1.png)

    * 반환되는 형태에 따른 서브쿼리 분류

      | 서브쿼리 종류                                   | 설명                                                         |
      | ----------------------------------------------- | ------------------------------------------------------------ |
      | Single Row 서브쿼리 <br />(단일 행 서브쿼리）   | 서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리를 의미한다. 단일 행 서브쿼리는 단일 행 비교 연산자와 함께 사용된다. 단일 행 비교 연산자에는 =, <, <=. >, >=,〈〉이 있다. |
      | Multi Row 서브쿼리 <br />(다중 행 서브쿼리）    | 서브쿼리의 실행 결과가 여러 건인 서브쿼리를 의미한다. 다중 행 서브쿼리는 다중 행 비교 연산자와 함께 사용된다. 다중 행 비교 연산자에는 IN, ALL, ANY. SOME, EXISTS가 있다. |
      | Multi Column 서브쿼리 <br/>(다중칼럼 서브쿼리） | 서브쿼리의 실행 결과로 여러 칼럼을 반환한다. 메인쿼리의 조건절에 여러 칼럼을 동시에 비교할 수 있다. 서브쿼리와 메인쿼리에서 비교 하고자 하는 칼럼 개수와 칼럼의 위치가 동일해야 한다. |

16. 서브쿼리를 사용시 주의사항 

    * 서브쿼리를 괄호로 감싸서 사용한다.

    * 서브쿼리는 단일 행(Single Row) 또는 복수 행(Multiple Row) 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1 건 이하이어야 하고 복수 행 비교 연산자는 서브쿼리의 결과 건수와 상관없다. 

    * 서브쿼리에서는 ORDER BY를 사용하지 못한다. ORDER BY절은 SELECT절에서 오직 한 개만 올 수 있기 때문에 ORDER BY절은 메인쿼리의 마지막 문장에 위치해야 한다.

17. 인라인 뷰(Inline View)

    FROM 절에서 사용되는 서브쿼리를 **인라인 뷰(Inline View)**라고 한다. 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다. 인라인 뷰는 SQL문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 데이터베이스에 해당 정보가 저장되지 않는다. 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다. 인라인 뷰는 SQL문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 데이터베이스에 해당 정보가 저장되지 않는다. 

18. 뷰 사용의 장점

    |                            독립성                            |                            편리성                            |                            보안성                            |
    | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다. | 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. 또한 해당 형태의 SQL문을 자주 사용할 때 뷰를 이용하면 편리하게 사용할 수 있다. | 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면 뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다. |

19. Grouping Columns
    **Grouping Columns**이 가질 수 있는 모든 경우에 대하여 Subtotal을 생성해야 하는 경우에는 CUBE를 사용하는 것이 바람직하나, ROLLUP에 비해 시스템에 많은 부담을 주므로 사용에 주의해야 한다.

20. CUBE

    **CUBE**는 결합 가능한 모든 값에 대하여 다차원 집계를 생성한다. CUBE도 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 명시적으로 정렬 칼럼이 표시가 되어야 한다.

21. GROUPING SETS

    **GROUPING SETS**은 다양한 소계 집합을 만들 수 있는데, GROUPING SETS에 표시된 인수들에 대한 개별 집계를 구할 수 있으며, 이때 표시된 인수들 간에는 계층 구조인 ROLLUP과는 달리 평등한 관계이므로 안수의 순서가 바뀌어도 결과는 같다. 그리고 GROUPING SETS 함수도 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 명시적으로 정렬 칼럼이 표시가 되어야 한다. 

22. RANK 함수

    **RANK** 함수는 ORDER BY를 포함한 QUERY 문에서 특정 항목(칼럼)에 대한 순위를 구하는 함수이며 동일한 값에 대해서는 동일한 순위를 부여하게 된다.

23. DENSE_RANK

    DENSE_RANK 함수는 RANK 함수와 흡사하나, 동일한 순위를 하나의 건수로 취급하는 것이 다른 점이다. 

24. ROW_NUMBER

    **ROW_NUMBER** 함수는 RANK나 DENSE_RANK 함수가 동일한 값에 대해서는 동일한 순위를 부여하는데 반해, 동일한 값이라도 고유한 순위를 부여한다. 

25. LAG

    LAG 함수를 이용해 파티션별 윈도우에서 이전 몇 번째 행의 값을 가져올 수 있다. 이후 몇 번째 행의 값을 가져오는 것은 LEAD 함수이며, SQL Server에서는 지원하지 않는 함수이다.

26. PL/SQL의 특징

    * PL/SQL은 Block 구조로 되어있어 각 기능별로 모듈화가 가능하다. 
    * 변수. 상수 등을 선언하여 SQL 문장 간 값을 교환한다. 
    * IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램이 가능하도록 한다. 
    * DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있다. 
    * PL/SQL은 Oracle에 내장되어 있으므로 Oracle과 PL/SQL을 지원하는 어떤 서버로도 프로그램을 옮길 수 있다. 
    * PL/SQL은 응용 프로그램의 성능을 향상시킨다. 
    * PL/SQL은 여러 SQL 문장을 Block으로 묶고 한 번에 Block 전부를 서버로 보내기 때문에 통신량을 줄일 수 있다.

27. 저장 모듈(Stored Module)
    SQL 문장을 데이터 베이스 서버에 저장하여 사용자와 애플리케이션 사이에서 공유할 수 있도록 만든 일종의 SQL 컴포넌트 프로그램이며, 독립적으로 실행되거나 다른 프로그램으로부터 실행될 수 있는 완전한 실행 프로그램이다. Oracle의 저장 모듈에는 Procedure, User Defined Function, Trigger가 있다.

28. 프로시저와 트리거의 차이점

    | 프로시저                   | 트리거                     |
    | -------------------------- | -------------------------- |
    | CREATE Procedure 문법 사용 | CREATE Trigger 문법 사용   |
    | EXECUTE 명령어로 실행      | 생성 후 자동으로 실행      |
    | COMMIT, ROLLBACK 실행 가능 | COMMIT, ROLLBACK 실행 안됨 |

    